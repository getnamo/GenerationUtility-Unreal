<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Visualization</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.js"></script>
<script>
// PriorityQueue class
class PriorityQueue {
    constructor() {
        this.nodes = [];
    }

    enqueue(priority, key) {
        this.nodes.push({ key, priority });
        this.sort();
    }

    dequeue() {
        return this.nodes.shift();
    }

    sort() {
        this.nodes.sort((a, b) => a.priority - b.priority);
    }

    isEmpty() {
        return !this.nodes.length;
    }
}

// Pseudo-random number generator with a seed
function mulberry32(a) {
    return function() {
        var t = a += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
}

// Generate random set of points
function generateRandomPoints(numPoints, seed, scale=100) {
	const rand = mulberry32(seed);
	const points = [];
	for (let i = 0; i < numPoints; i++) {
		points.push({ id: i, X: rand() * scale, Y: rand() * scale, Z: rand() * scale });
	}
	return points;
}

// Calculate edges based on Euclidean distance and a given radius
function calculateEdges(points, radius) {
    const edges = [];
    for (let i = 0; i < points.length; i++) {
        for (let j = i + 1; j < points.length; j++) {
            const distance = euclidean(points[i], points[j]);
            if (distance <= radius) {
                edges.push({ from: points[i].id, to: points[j].id, weight: distance });
            }
        }
    }
    return edges;
}

// Example heuristic function (Euclidean distance in 3D)
function euclidean(node, end) {
    const dx = node.X - end.X;
    const dy = node.Y - end.Y;
    const dz = node.Z - end.Z;
    return Math.sqrt(dx * dx + dy * dy + dz * dz);
}

// Dijkstra's Algorithm
function dijkstra(adjacencyList, start, end) {
    const distances = new Map();
    const previous = new Map();
    const pq = new PriorityQueue();

    distances.set(start, 0);
    pq.enqueue(0, start);

    adjacencyList.forEach((_, vertex) => {
        if (vertex !== start) distances.set(vertex, Infinity);
        previous.set(vertex, null);
    });

    while (!pq.isEmpty()) {
        const { key: currentVertex } = pq.dequeue();

        if (currentVertex === end) {
            const path = [];
            let step = currentVertex;
            while (previous.get(step)) {
                path.push(step);
                step = previous.get(step);
            }
            return path.concat(start).reverse();
        }

        adjacencyList.get(currentVertex).forEach(neighbor => {
            const alt = distances.get(currentVertex) + neighbor.weight;
            if (alt < distances.get(neighbor.to)) {
                distances.set(neighbor.to, alt);
                previous.set(neighbor.to, currentVertex);
                pq.enqueue(alt, neighbor.to);
            }
        });
    }

    return [];
}

// A* Algorithm
function aStar(adjacencyList, start, end, heuristic = euclidean) {
    const distances = new Map();
    const previous = new Map();
    const pq = new PriorityQueue();

    distances.set(start, 0);
    pq.enqueue(0, start);

    adjacencyList.forEach((_, vertex) => {
        if (vertex !== start) distances.set(vertex, Infinity);
        previous.set(vertex, null);
    });

    while (!pq.isEmpty()) {
        const { key: currentVertex } = pq.dequeue();

        if (currentVertex === end) {
            const path = [];
            let step = currentVertex;
            while (previous.get(step)) {
                path.push(step);
                step = previous.get(step);
            }
            return path.concat(start).reverse();
        }

        adjacencyList.get(currentVertex).forEach(neighbor => {
            const alt = distances.get(currentVertex) + neighbor.weight;
            if (alt < distances.get(neighbor.to)) {
                distances.set(neighbor.to, alt);
                previous.set(neighbor.to, currentVertex);
                const priority = alt + heuristic(neighbor.to, end);
                pq.enqueue(priority, neighbor.to);
            }
        });
    }

    return [];
}

// Example usage
const numPoints = 500;
const radius = 6;


seed = Math.random()*10000;
seed = 12345;

const vertices = generateRandomPoints(numPoints, seed, 40);
const edges = calculateEdges(vertices, radius);

// Create adjacency list
const adjacencyList = new Map();

vertices.forEach(vertex => {
    adjacencyList.set(vertex, []);
});

edges.forEach(edge => {
    const fromVertex = vertices.find(v => v.id === edge.from);
    const toVertex = vertices.find(v => v.id === edge.to);
    adjacencyList.get(fromVertex).push({ to: toVertex, weight: edge.weight });
    adjacencyList.get(toVertex).push({ to: fromVertex, weight: edge.weight }); // if the graph is undirected
});

// Find shortest path using Dijkstra
const startVertex = vertices[0]; // Example start point
const endVertex = vertices[99];  // Example end point
const shortestPath = dijkstra(adjacencyList, startVertex, endVertex);

// Visualization using Three.js
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Add orbit controls
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.update();

// Add points
const pointMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
vertices.forEach(vertex => {
    const geometry = new THREE.SphereGeometry(0.5, 32, 32);
    const point = new THREE.Mesh(geometry, pointMaterial);
    point.position.set(vertex.X, vertex.Y, vertex.Z);
    scene.add(point);
});

// Add shortest path edges
const pathMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
for (let i = 0; i < shortestPath.length - 1; i++) {
    const start = shortestPath[i];
    const end = shortestPath[i + 1];
    const points = [];
    points.push(new THREE.Vector3(start.X, start.Y, start.Z));
    points.push(new THREE.Vector3(end.X, end.Y, end.Z));
    const geometry = new THREE.BufferGeometry().setFromPoints(points);
    const line = new THREE.Line(geometry, pathMaterial);
    scene.add(line);
}

// Set camera position
camera.position.z = 150;

const animate = function () {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
};

animate();
</script>
</body>
</html>
